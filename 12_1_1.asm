
;			12.11		单步中断

;CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程：
;(1)取得中断类型码1
;(2)标志寄存器入栈，TF、IF设置为0
;(3)CS、IP入栈
;(4)(IP)=(1*4),(CS)=(1*4+2)

;Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。然后，
;在使用t命令执行指令时，Debug将TF设置为1，使得CPU工作于单步中断方式下，则CPU在执行完这
;条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器的内容被显示在屏幕上，
;等待输入命令。

;在进入中断处理程序之前，设置TF=0.c从而避免CPU在执行中中断处理程序的时候发生单步中断

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;					12.12		响应中断的特殊情况

;在执行完向ss寄存器传送数据的指令后，即便是发生中断，CPU也不会响应。这样做的原因是
;ss:sp指向栈顶，而对它们的设置应该连续完成。如果在执行完ss的指令后，CPU响应中断，
;引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp并未改变。ss:sp指向
;的不是正确的栈顶，将引起错误。所以CPU在执行完设置ss的指令后，不响应中断。这给连续
;设置ss和sp指向正确的栈顶提供了一个时机。即我们利用这个特性，将设置ss和sp的指令连续
;存放，使得设置sp的指令紧接着设置ss的指令。而在此之间，CPU不会引发中断过程

;比如设置栈顶为1000:0，应该：

mov ax,1000h
mov ss,ax
mov sp,0

;而不应该：

mov ax,1000h
mov ss,ax
mov ax,0
mov sp,0