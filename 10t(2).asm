;实验10			(2) divdw子程序
;应用举例：计算1000000/10(f4240h/0ah)
;名称：divdw

;功能：进行不会产生溢出的除法运算，被除数为dword型，除数为word型，结果为dword型。

;参数：(ax)=dword型数据的低16位；

;      (dx)=dword型数据的高16位；

;      (cx)=除数。

;返回：(dx)=结果的高16位；

;      (ax)=结果的低16位；

;      (cx)=余数。

assume cs:code

code segment

start:	mov ax,4240h			;(ax)=dword型数据的低16位；
		mov dx,000fh			;(dx)=dword型数据的高16位；
		mov cx,0ah				;(cx)=除数
		call divdw				;调用子程序divdw
		
		mov ax,4c00h
		int 21h
		
		
divdw:	push si					;被除数中ax存低16位，dx存高16位
		push bx					;16位除法时ax存商，dx存余数
		push ax
		
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

					"""高位除法"""
		mov ax,dx				;把高位000fh放ax中
		mov dx,0				;这里进行的是高位的除法用不到dx，所以dx置0，防止影响结果
		div cx					;被除数的高位（在这里相当于低16位ax，高16位dx=0）/cx,
								;高位商在ax,余数在dx（作为低位除法的高16位）
		mov si,ax				;把高位除法运算后的商放入si
		
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					
;					"""低位除法"""
		pop ax					;恢复低位数据4240h，进行低位除法，此时dx中为高位除法后
								;的余数,可作为低位除法的dx（也就是低位除法的高16位）
		div cx					;(被除数高位（余数dx）+低位)/cx,高位在ax,余数在dx
		mov cx,dx				;余数入cx
		mov dx,si				;高位的商入dx，低位除法后低位的商在ax中
		
		pop bx
		pop si
		ret
		
code ends

end start
;公式x/n=int(h/n)*65536+[rem(h/n)*65536+l]/n解析： 

;把一个会溢出的除法 变成几个除法来做！ 

;如果高位除法有商，那么商就是结果的高位值，如果会有余数，那么余数自然不能丢弃，
;余数就作为低位除法的dx(也就是高位的被除数，因为他是从高位除法中余下的）  

;做低位除法的时候，就拿余下的dx+低位数的ax除以除数，会得到 一个低位的商 和 余数  

;高位的商+低位数的商+余数 就是结果

;这个程序的理解和完成，应该是这章比较重要的一个点。
;咱得多注意这种变通和分解的方式来处理问题的思维方式。

