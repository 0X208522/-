
;				13.1 int指令

;中断信息可以来自CPU内部和外部，当CPU的内部有内部需要处理的事情发生时，将产生需要马上
;处理的中断信息，引发中断过程。12章讲了两种中断即除法错误中断和单步中断，这里的int指令
;引发的中断也是一种内中断

;int指令的格式：int n,n为中断类型码，它的功能是引发中断过程
;CPU执行int n指令，相当于引发一个n号中断的中断过程，过程如下：
;(1)取中断类型码n
;(2)标志寄存器入栈，IF=0,TF=0
;(3)CS、IP入栈
;(4)(IP)=(n*4),(CS)=(n*4+2)
;从此处转去执行n号中断的中断处理程序


;可以在程序中使用int指令调用任何一个中断的中断处理程序，如下：
assume cs:code

code segment

start:	mov ax,0b800h
		mov es,ax
		mov byte ptr es:[12*160+40*2],'!'
		int 0
		
code ends

end start

;这个程序将在屏幕中间显示一个“！”，然后显示“Divide overflow”后返回系统中，因在程序
;中没有除法错误，不可能产生除法溢出，那“Divide overflow”哪里来的？这里是因为使用了
;int 0指令。CPU执行int 0指令时，将引发中断过程，执行0号中断处理程序，而系统设置的0号
;中断处理程序的功能是显示"Divide overflow",然后返回系统。

;可见，int指令的最终功能和call指令相似，都是调用一段程序。

;一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用
;我们在编程的时候，可以使用int指令调用这些子程序。当然，也可以自己编写一些中断处理
;程序供别人使用。以后，我们可以将中断处理程序简称为中断例程。