
;				13_3(2)		在屏幕中间显示80个'!'

;为了模拟loop指令，7ch中断例程应具备下面的功能：
;(1)dec cx
;(2)如果（cx）不等于0，转到标号s处执行，否则向下执行

;下面分析7ch中断例程如何实现到目的地址的转移。
;(1)转到标号s显然应设（CS）=标号s的段地址，（IP）=标号s的偏移地址
;(2)那么，中断例程如何得到标号s的段地址和偏移地址呢？
;	int 7ch引发中断过程后，进入7ch中断例程，在中断过程中，当前的标志寄存器、CS和IP都要
;压栈，此时压入的CS和IP的内容，分别是调用程序的段地址（可以认为是标号s的段地址）和int 7ch
;后一条指令的偏移地址（即标号se的偏移地址）

;可见，在中断例程中，可以从栈里取得标号s的段地址和标号se的偏移地址加上bx中存放的转移
;位移就可以得到标号s的偏移地址,从栈中直接和间接的得到标号s的段地址和偏移地址，那么如何
;用它们设置CS:IP呢？
;可以利用iret指令，我们将栈中的se的偏移地址加上bx中的转移位移，则栈中的se的偏移地址
;就变为了s的偏移地址。我们再使用iret指令，用栈中的内容设置CS、IP，从而实现转移到标号s处

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;7ch中断例程如下。
lp:		push bp					;栈顶处是bp原来的值，入栈保存
		mov bp,sp				
		dec cx
		jcxz lpret				;如果cx=0则跳到lpret处执行，否则向下执行
		add [bp+2],bx			;bx代表位移的长度，此处（(ss)*1+(bp)+2）为se的偏移地址
								;将它加上bx就变为s的偏移地址
lpret:	pop bp
		iret					;用iret出栈返回，CS:IP即从标号s处开始执行指令
		
;解析：		
;因为要访问栈，使用了bp，在程序开始处将bp入栈保存，结束时出栈恢复。当要修改栈中se的偏移
;地址的时候，栈中的情况为：栈顶处是bp原来的数值，下面是se的偏移地址，再下面是s的段地址，
;再下面是标志寄存器的值。而此时，bp中为栈顶的偏移地址，所以（(ss)*16+(bp)+2）处为se的偏移
;地址，将它加上bx中的转移位移就变为s的偏移地址。最后用iret出栈返回，CS:IP即从标号s处开始
;执行代码

;如果（cx）=0，则不需要修改栈中se的偏移地址，直接返回即可。CPU从标号se处向下执行代码。